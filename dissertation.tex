% Template for a Computer Science Tripos Part II project dissertation
\documentclass[12pt,a4paper,twoside,openright]{report}
\usepackage[pdfborder={0 0 0}]{hyperref}    % turns references into hyperlinks
\usepackage[margin=25mm]{geometry}  % adjusts page layout
\usepackage{graphicx}  % allows inclusion of PDF, PNG and JPG images
\usepackage{verbatim}
\usepackage{listings}
\usepackage{color}
\usepackage{courier}
\usepackage{tikz}
\usepackage{enumitem}
\usepackage{float}
\floatstyle{plain}
\restylefloat{figure}
\usetikzlibrary{decorations.pathreplacing,shapes,arrows,shadows,decorations.markings}
\graphicspath{ {images/} }
\usepackage{natbib}
\usepackage{latexsym}
\usepackage{amsmath}

\definecolor{myblue}{rgb}{0,0.05,0.75}

\lstset{
aboveskip=20pt,
backgroundcolor = \color{white},
basicstyle = \footnotesize\ttfamily,
belowskip=10pt,
breakatwhitespace=false,
breaklines=false,
captionpos=b,
commentstyle = \color{myblue},
extendedchars=true,
float,
floatplacement=H,
frame=single,
keepspaces=true,
language=Tex,
mathescape,
numbers=left,
numbersep=5pt,
numberstyle=\tiny\color{myblue},
stepnumber=1,
xleftmargin=.2\textwidth,
xrightmargin=.2\textwidth
}

\raggedbottom                           % try to avoid widows and orphans
\sloppy
\clubpenalty1000%
\widowpenalty1000%

\renewcommand{\baselinestretch}{1.1}    % adjust line spacing to make
                                        % more readable

\begin{document}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Title


\pagestyle{empty}

\rightline{\LARGE \textbf{James Wright}}

\vspace*{60mm}
\begin{center}
\Huge
\textbf{Formalising the semantics of algebraic effects in OCaml} \\[5mm]
Computer Science Tripos -- Part II \\[5mm]
Trinity Hall \\[5mm]
\today  % today's date
\end{center}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Proforma, table of contents and list of figures

\pagestyle{plain}

\chapter*{Proforma}

{\large
\begin{tabular}{p{4.4cm}p{11cm}}
Name:               & \bf James Wright                       \\
College:            & \bf Trinity Hall                     \\
Project Title:      & \bf Formalising the semantics of algebraic effects in OCaml \\
Examination:        & \bf Computer Science Tripos -- Part II, 2015--16  \\
Word Count:         & \bf unknown  \\
Project Originator: & KC Sivaramakrishnan                    \\
Supervisor:         & KC Sivaramakrishnan                    \\ 
\end{tabular}
}


\section*{Original Aims of the Project}

To formalise the semantics of algebraic effects, a proposed addition to OCaml, as a CEK machine, in order to perform subsequent random and exhaustive testing of concurrent schedules in the program. The testing should allow us to show desirable properties such as determinism and absence of deadlock.

\section*{Work Completed}

\section*{Special Difficulties}

None.
 
\newpage
\section*{Declaration}

I, James Wright of Trinity Hall, being a candidate for Part II of the Computer
Science Tripos, hereby declare
that this dissertation and the work described in it are my own work,
unaided except as may be specified below, and that the dissertation
does not contain material that has already been used to any substantial
extent for a comparable purpose.

\bigskip
\leftline{Signed}

\medskip
\leftline{Date}

\tableofcontents

\listoffigures

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% now for the chapters

\pagestyle{headings}

\chapter{Introduction}

\section{Algebraic effects}

There exist multicore-capable functional programming languages, such as Haskell, Manticore, F\#, and MultiMLton, whose runtimes provide support for concurrency---the concurrency primitives are baked in to the runtime system. This has the advantage of natively supporting multicore capabilities, but it also means that the runtimes can become burdensomely complicated. OCaml, on the other hand, is not yet multicore-capable and does not have this concurrency support.

The OCaml Labs team have been working on a multicore OCaml compiler, which includes as a feature algebraic effects. In contrast to the implementations in the other aforementioned functional programming languages, algebraic effects provide a modular abstraction for expressing effectful computation, which allows programmers to implement independent schedulers and new concurrency primitives as OCaml libraries.

\section{Formalisation}

Formalisation langauges exist, which allow another language's semantics to be modelled. The first benefit of this is that when the language description is compiled, this necessarily tests that the language is consistent, \textit{e.g.} that no trivial mistakes such as omitting a particular form of expression have been made. The second and more powerful application of formalisation is that once compiled the semantics can be tested by simulating execution traces and determining whether a particular program has a particular property.

\section{Motivation}

The syntax and semantics for algebraic effects have been designed and implemented by OCaml Labs, but the new semantics has not yet been formalised. Formalisation allows for random and exhaustive testing of concurrent schedules, which would allow us to show properties such as determinism or absence of deadlock.

\section{Summary}

The aim for the project was to:

\begin{enumerate}[label=(\alph*)]
\item formalise the semantics of algebraic effects; and
\item use this formalisation to be able to test schedulers and programs for desirable properties.
\end{enumerate}

\chapter{Preparation}

In this chapter I will describe the background theory I investigated in order to understand the problem. In Section \ref{preppara} I explain the principles of parasitic threads; in Section \ref{prepalg} I explain the principles of algebraic effects, and how they relate to parasitic threads; Section \ref{prepcek} onwards cover the formalisation process and the tools I used.

\section{Starting point}\label{prepstart}

My project is very much building on work already undertaken by OCaml Labs. Algebraic effects semantics have been designed and implemented in OCaml by the OCaml Labs team, who have also produced documentation that illustrates the behaviour of algebraic effects and provides examples of schedulers that exploit algebraic effects.

My implementation of algebraic effects as a CEK machine is heavily based on KC Sivaramakrishnan's description of parasitic threads as a CEK machine.\cite{Siv2014}

\section{Parasitic threads}\label{preppara}
Parasitic threads are a system for implementing multi-thread behaviour inside a single processor thread. The processor thread maintains a list of parasitic threads, and a list of channels. Each parasitic thread is made up of a parasite stack, which is similar to subroutines on a call stack. The parasite on top is the one that is being executed. Execution may include: 

\begin{itemize}
\item spawning a parasite, which creates a new parasite that is put on top of the stack; 
\item attaching a continuation, which creates a parasite to evaluate the continuation;
\item sending a value into a channel;
\item receiving a value from a channel; and 
\item terminating, which removes the parasite from the stack \textit{without} returning a value to the parasite beneath it.
\end{itemize}

The scheduling of threads is handled implicitly by the system, which is free to pre-empt a thread at any time.  Threads may synchronise exclusively through sending values into channels. Channels are non-buffering, \textit{i.e.}, execution of a sender is blocked until another parasite tries to receive from the same channel.

\section{Algebraic effects}\label{prepalg}

The system of algebraic effects is based on parasitic threads. The key distinction is that scheduling is now handled explicitly by the program that is being executed. The execution occurs entirely within a single thread, which is made up of a fibre stack -- analogous to the parasite stack of parasitic threads. Each fibre is also made up of a stack of frames. Another difference is that when a fibre terminates the value of the expression \textbf{is} returned to the fibre beneath it on the fibre stack.

The explicit scheduling involves the addition of two new forms of expression to the language. The semantics of the first, \texttt{handle(g, h\_eff, h\_val)}, are equivalent to that given in Listing \ref{lst:handle}, where \texttt{g} is a fibre, and \texttt{g()} represents the result of the computation done by the fibre.


\begin{minipage}{\linewidth} \begin{lstlisting}[caption=The semantics of \texttt{handle},label={lst:handle}]
  match g() with:
    | v            => h_val(v)
    | effect(k, v) => h_eff(k, v)
\end{lstlisting} \end{minipage}

The expression \texttt{effect(k,v)} represents a continuation, where \texttt{k} is the rest of the evaluation of \texttt{g()} and \texttt{v} is an extra argument passed to \texttt{h\_eff}. It can be returned only when \texttt{g()} evaluates the subexpression \texttt{perform(v)}, which is the second new expression.

The way this is implemented in terms of fibres is as follows: when the fibre \texttt{f} evaluates the expression \texttt{handle(g, h\_eff, h\_val)}, two fibres are pushed to the stack. The first fibre represents \texttt{(h\_eff, h\_val)} and the second represents \texttt{g}. Since the fibre \texttt{g} is now on top of the fibre stack, it is the fibre that is executed. If and when the fibre eventually terminates, the result is returned.

\section{CEK machines}\label{prepcek}

A CEK machine is a mechanical model for semantics. It is made up of a control component (C), an environment component (E), and a continuation component (K). The control component represents the current state of execution. I will use three states:

\begin{itemize}
\item the \textbf{control($e$)} state, which means that the expression $e$ is currently being evaluated;
\item the \textbf{return} state, which means that a \texttt{ret} frame has been pushed onto the continuation stack, and the continuation should now be executed; and
\item the \textbf{halt($v$)} state, which means that the machine's execution has concluded and the value $v$ is returned.
\end{itemize}

The environment component is a function from variable names to values. The continuation component is a stack of frames which represent the remainder of the computation.

\begin{figure}
\centering
\caption{Evaluation of the expression (($\lambda$ x x) unit) in a language encoded in a CEK machine}
\label{fig:parasem}
\tikzstyle{frame}=[draw, fill=blue!10, text width=7em, text centered, minimum height=2em, minimum width=5em]
\tikzstyle{thread}=[draw, fill=blue!25,minimum height=3em, minimum width=5em, text centered]
\tikzstyle{state}=[text width=4em, text centered,font=\bf]
\tikzstyle{vtranlabel}=[right=0.5em,font=\tt]
\tikzstyle{vtranarrow}=[line width = 1.2pt]
\begin{tikzpicture}[remember picture]

\draw(0,0) node[thread](A){

\begin{tikzpicture}
\draw (0,-0) node[state,text width=8em]{control\\(($\lambda$ x x) unit)\\\{\}};
\end{tikzpicture}

};

\draw(0,-3) node[thread](B){
\begin{tikzpicture}
\draw (0,0) node[frame]{arg(unit,\{\})};
\draw (-2.5,0) node[state]{control\\($\lambda$ x x)\\\{\}};
\end{tikzpicture}
};

\draw(0,-6) node[thread](C){
\begin{tikzpicture}
\draw(0,0) node[frame]{ret($\lambda$ x x \{\})};
\draw (0,-0.9) node[frame]{arg(unit,\{\})};
\draw (-2.5,-0.45) node[state]{return};
\end{tikzpicture}
};

\draw(0,-9) node[thread](D){
\begin{tikzpicture}
\draw (0,0) node[frame]{fun(($\lambda$ x x \{\}))};
\draw (-2.5,0) node[state]{control\\unit\\\{\}};
\end{tikzpicture}
};


\draw(0,-12) node[thread](E){
\begin{tikzpicture}
\draw(0,0) node[frame]{ret(unit)};
\draw (0,-0.9) node[frame]{fun(($\lambda$ x x\{\}))};
\draw (-2.5,-0.45) node[state]{return};
\end{tikzpicture}
};

\draw(0,-15) node[thread](F){
\begin{tikzpicture}
\draw (0,-0) node[state,text width=8em]{control\\x\\\{x : unit\}};
\end{tikzpicture}
};

\draw(0,-18) node[thread](G){
\begin{tikzpicture}
\draw(0,0) node[frame]{ret(unit)};
\draw (-2.5,-0) node[state]{return};
\end{tikzpicture}
};

\draw(0,-20.5) node[thread](H){
\begin{tikzpicture}
\draw (0,-0) node[state,text width=8em]{halt\\unit};
\end{tikzpicture}
};

\draw[->,vtranarrow] (A) to node[vtranlabel]{application} (B);
\draw[->,vtranarrow] (B) to node[vtranlabel]{closure} (C);
\draw[->,vtranarrow] (C) to node[vtranlabel]{argument} (D);
\draw[->,vtranarrow] (D) to node[vtranlabel]{value} (E);
\draw[->,vtranarrow] (E) to node[vtranlabel]{function} (F);
\draw[->,vtranarrow] (F) to node[vtranlabel]{variable} (G);
\draw[->,vtranarrow] (G) to node[vtranlabel]{threadHalt} (H);

\end{tikzpicture}
\end{figure}

Figure \ref{fig:parasem} depicts the execution of a simple program, which evaluates (($\lambda$ x x) unit). This example demonstrates various categories of reduction rules:

\begin{itemize}
\item Rules like \texttt{application} divide a compound expression like \texttt{(e\_1 e\_2)} into its subexpressions, transitioning to a state where one of the subexpressions, \texttt{e\_1} is the expression being evaluated, and the remainder is pushed onto the frame stack, in this case in an \texttt{arg} frame.
\item Rules like \texttt{value} and \texttt{variable} complete an expression's evaluation by transitioning into a return state and pushing a \texttt{ret} frame onto the frame stack.
\item Rules like \texttt{argument} and \texttt{function} combine the top two frames on the frame stack while in the return state.
\item The rule \texttt{threadHalt} finishes execution by transitioning from a return state where there is a single \texttt{ret} frame on the frame stack to the halt state.
\end{itemize}

The full semantics of parasitic threads encoded as a CEK machine are presented by Sivaramakrishnan, et al., in MultiMLton: A multicore-aware runtime for standard ML.\cite{Siv2014}

\section{PLT Redex}\label{prepplt}

For the formalisation I chose to use PLT Redex, which is a language embedded in Racket that is designed for specifying and testing operational semantics. A PLT Redex program can be used to specify, among other things:

\begin{itemize}
\item the language whose semantics are being described (the syntax);
\item a reduction relation on the language (the semantics);
\item unit tests for regression testing; and
\item the type system for the language.
\end{itemize}

I familiarised myself with PLT Redex through the Racket tutorial\footnote{http://docs.racket-lang.org/redex/tutorial.html}, on which the following demonstration is based. The tutorial implements a model of the $\lambda$-calculus with an additional 'amb' operator. This introduced the main concepts of the language that I would later use to formalise algebraic effects.

\begin{minipage}{\linewidth} \begin{lstlisting}[caption=Defining a language in PLT Redex,label={lst:redex1}]
(define-language L
  (e (e e)         %application
      ($\lambda$ x e)      %lambda function
      x            %variable
      (amb e ...)) %amb operator
  (x variable-not-otherwise-mentioned))
\end{lstlisting} \end{minipage}

A language is described by a set of non-terminals and expressions that match these non-terminals. In Listing \ref{lst:redex1} the non-terminals are \texttt{e} and \texttt{x}.

In order to write a reduction relation, it is idiomatic to write a small extension to the language that not only defines what it means for an expression in the language to be a program, but also defines the evalation context.

\begin{minipage}{\linewidth} \begin{lstlisting}[caption=An extended language based on L,label={lst:redex2}]
(define-extended-language Ext L
  (p (e ...))
  (P (e ... E e ...))
  (E (v E)
     (E e)
     hole)
  (v ($\lambda$ x e)))
\end{lstlisting} \end{minipage}

In Listing \ref{lst:redex2} the non-terminal \texttt{p}, which represents a program, is matched to a (possibly zero-length) list of \texttt{e}. The non-terminal \texttt{E} represents an evaluation context, and is matched to the special symbol \texttt{hole} in order to identify it as such. In order that a function is evaluated before its argument, \texttt{E} is matched to the expression \texttt{(v E)}, rather than to \texttt{(e E)}.

\begin{minipage}{\linewidth} \begin{lstlisting}[caption=Defining a reduction relation in PLT Redex,label={lst:redex3}]
(define red
  (reduction-relation
   Ext
  #:domain p
   (--> (in-hole P (($\lambda$ x e) v))
        (in-hole P (subst x v e))
        "application")
   (--> (e_1 ... (in-hole E (amb e_2 ...)) 
          e_3 ...)
        (e_1 ... (in-hole E e_2) ... e_3 ...)
        "amb")))
\end{lstlisting} \end{minipage}

The reduction relation is defined in Listing \ref{lst:redex3}. The first rule, \texttt{"application"}, uses a separately-defined metafunction \texttt{subst} to reduce a function application to the expression within the function, with the bound variable being substituted by the value of the argument. The second rule, \texttt{"amb"}, defines the semantics of amb.

The use of PLT Redex goes beyond merely specifying a language, however. The reduction relation can then be applied on an expression in the language in order to execute the semantics.

\begin{minipage}{\linewidth} \begin{lstlisting}[caption=Applying the reduction relation with transitive closure,label={lst:redexample1}]
> (apply-reduction-relation* red (term
      ((($\lambda$ x (amb x x)) ($\lambda$ x x)))))
'((($\lambda$ x x) ($\lambda$ x x)))
\end{lstlisting} \end{minipage}

Listing \ref{lst:redexample1} depicts use of PLT Redex's command line interface. The function \texttt{apply-reduction-relation*} applies the transitive closure of the reduction relation, \textit{i.e.} it repeatedly applies the reduction relation \texttt{red} until the expression does not reduce further. Since reduction relations may be non-deterministic, it returns a list of all irreducible expressions found in the reduction tree.

\begin{figure}
\centering
\caption{PLT Redex's \texttt{traces} function}
\label{fig:traces_example}
\includegraphics[scale=0.75]{traces_example}
\end{figure}

The function \texttt{apply-reduction-relation*} can also be called with the option \texttt{all?} in order to include the entire set of terms, rather than just the irreducible terms. PLT Redex also offers the \texttt{traces} function, which graphically represents the reduction tree. For example, the graph in Figure \ref{fig:traces_example} shows the terms in the reduction tree for the term used in Listing \ref{lst:redexample1} as well as the names of the rules by which the subsequent terms were derived.

\section{Tools used}

I wrote the Racket code in DrRacket, a graphical development environment. This has a command line interface which allowed me to query the languages once they had been compiled. I used Git for source control for the code and the written artifacts, and regularly pushed to a Github repository for backup purposes.

\chapter{Implementation}

In sections \ref{implfirst}--\ref{impllast} I present the implementation of the algebraic effects CEK machine, which was based on the parasitic threads CEK machine. In sections \ref{implproving} onwards I show an example usage of the CEK machine---in this case, to determine whether particular schedules and programs have certain properties.

\section{Parasitic threads}\label{implfirst}

I started by implementing the semantics of parasitic threads. Since the semantics of algebraic effects are similar to and based on the semantics of parasitic threads, and a CEK machine that modelled the semantics of parasitic threads had already been described,\cite{Siv2014} this provided an easier path to the algebraic effects semantics than starting from scratch.

The parasitic thread semantics include features, like multiple threads and multiple channels along with transition rules that deal with spawning new threads and sending and receiving information through channels, that don't exist in the algebraic effects semantics. I chose to omit these features from my implementation of parasitic thread semantics in order to avoid wasted effort.

The implementation itself can be found in Appendix XXXXX. The language, \texttt{Pt}, has 7 non-terminals and 10 reduction rules, which is reduced from the 12 non-terminals and 27 rules of the language as originally encoded. Examples of executions of \texttt{Pt} programs are given in Figures \ref{fig:traces_trivial} and \ref{fig:traces_parasite}. 

\begin{figure}
\centering
\caption{Evaluating \texttt{(($\lambda$ x x) unit)} in \texttt{Pt}}
\label{fig:traces_trivial}
\includegraphics[scale=0.65]{traces_trivial}
\end{figure}

\begin{figure}
\centering
\caption{Evaluating \texttt{(spawn (attach ((ret unit))))} in \texttt{Pt}}
\label{fig:traces_parasite}
\includegraphics[scale=0.6]{traces_parasite}
\end{figure}

During implementation I discovered a mistake in the original semantics. The rule \texttt{closure} had been given as
$$\langle\lambda x.e, r, k, \overline{k} \rangle \longrightarrow \langle \texttt{ret} \lceil \lambda x.e.r \rceil : k \lhd \overline{k} \rangle$$
while the expression forms had been given as:

\begin{align} 
\nonumber e \in Exp &::= v\:  |\:  ... \\
\nonumber v \in Val &::= unit\:  |\:  (\lambda x.e.r)\:  |\:  ... \end{align}
where $r$ is an environment.

This meant that the left-hand side of the rule could not match any valid state, because it would be impossible to match $\lambda x.e$ with $e$

This means that $\lambda x.e$ did not match with $e$ so the left-hand side was not valid, which caused Racket to fail to compile the language. My solution was to add the form $\lambda x.e \in e$.

This discovery shows the usefulness of formalisation: the process of formalisation necessarily checked the semantics and led to the discovery of a mistake in a published paper.

\section{Algebraic effects}\label{impllast}

The framework I created for the parasitic threads CEK machine provided a basis for the algebraic effects implementation, \texttt{Alg}, which can be found in Appendix YYYYY. The additional features I implemented include:

\begin{itemize}
\item a global memory which can be assigned to and dereferenced with corresponding \texttt{ref} and \texttt{deref} expressions;
\item strings;
\item an 'if-equivalent' expression;
\item a \texttt{letrec} expression, which uses the memory for storing defined functions;
\item a tuple $(e_1, e_2)$, with \texttt{fst} and \texttt{snd} expressions for accessing the first and second element respectively;
\item a sequencing expression; and
\item the \texttt{handle}, \texttt{perform}, and \texttt{continue} expressions of algebraic effects.
\end{itemize}

\texttt{Alg} features 18 frame types, increased from \texttt{Pt}'s 3, and 36 reduction rules. An example program that demonstrates the algebraic effects semantics is reduced in Figure \ref{fig:traces_algebra}. The final step in the reduction, \texttt{threadHalt}, transforms the program to \texttt{(halt unit) ()}, which signifies that the bottom-most fibre has finished execution by returning the value \texttt{unit}, that all other fibres that may have been generated have also halted, and that nothing is stored in memory.

\begin{figure}
\centering
\caption{An example program in \texttt{Alg} that demonstrates the semantics of the \texttt{handle}, \texttt{perform}, and \texttt{continue} expressions}
\label{fig:traces_algebra}
\includegraphics[scale=0.35]{traces_algebra}
\end{figure}

\section{Proving properties}\label{implproving}

I could then use my CEK machine to simulate the semantics for a given scheduler and program, in order to determine whether they had certain properties. The properties I defined were:

\begin{itemize}
\item \textbf{determinism}, \textit{i.e.}, a given execution trace is deterministic \textbf{iff}, for all states $s_1$, $s_2$, $s_3$, $$s_1 \longrightarrow s_2 \wedge s_1 \longrightarrow s_3 \Rightarrow s_2 = s_3$$

I wrote the function \texttt{is\_deterministic} (see Listing \ref{lst:pltdeterminism}) to find whether a given program is deterministic. Given a scheduler expression $e_s$ and a program expression $e_p$, the exeuction of the scheduling semantics of $e_s$ on $e_p$ is deterministic iff \texttt{(is\_deterministic (term ((control (e\_s e\_p) ($\rho$) ()) ())))} returns true.

\begin{minipage}{\linewidth} \begin{lstlisting}[caption=A function that determines whether a scheduler and program in \texttt{Alg} are deterministic,label={lst:pltdeterminism}]
(define (is_deterministic p)
  (let ([next
         (apply-reduction-relation red p)])
    (cond
      [(empty? next) #t]
      [(equal? (length next) 1)
       (andmap is_deterministic next)]
      [else #f])))
\end{lstlisting} \end{minipage}

\end{itemize}

\section{Schedulers}
I could now use these functions to test the specific properties of schedulers I wrote. The first scheduler, "Scheduler 1" (see Listing \ref{lst:sched1}), uses the memory to store a stack of fibres that have been spawned, yielded, but not yet terminated. The stored functions \texttt{enq} and \texttt{deq} push and pop continuations to and from the stack respectively.

I then wrote a second scheduler, "Scheduler 2", based on Scheduler 1, which was designed to be incorrect. The change was to modify the \texttt{deq} function to simply return \texttt{unit}, instead of popping a continuation off the stack and continuing it.

I could then test the schedules for the properties given above, when used to run a suite of test programs. The full results are given in Appendix ZZZZZZ. As expected, while both schedulers were shown to be deterministic (at least, for all programs that terminated), Scheduler 2 was found to be incomplete for those programs that performed an effect, \textit{i.e.} returned control to the scheduler, during their evaluation.

\begin{minipage}{\linewidth} \begin{lstlisting}[caption=Scheduler 1 in \texttt{Alg},label={lst:sched1}]
((control ((ref q unit) \;
((ref deq ($\lambda$ x (if (deref q) unit unit
  (continue ((ref tmp (fst (deref q))) \;
    ((ref q (snd (deref q))) \;
      (deref tmp))) unit)))) \;
((ref enq ($\lambda$ x (ref q (x \, (deref q))))) \;
(($\lambda$ prog
  (letrec spawn 
  ($\lambda$ f 
    (handle f 
      ($\lambda$ x ((deref deq) unit)) 
      ($\lambda$ x 
        (if (fst (fst x)) 
        "Yield" 
        (((deref enq) (snd x)) \;
            ((deref deq) unit)) 
        (((deref enq) (snd x)) \;
            (spawn (snd (fst x))))))))
  (spawn prog))))))))
())
\end{lstlisting} \end{minipage}

\chapter{Evaluation}

In order to ascertain whether my implementation was working correctly, I wrote a suite of tests. The unit tests (Section \ref{testunit}) tested individual rules, and the functional tests (Section \ref{testfun}) tested the functionality of several rules working in sequence to provide the correct behaviour of the CEK machine.

\section{Unit tests}\label{testunit}

For each rule in \texttt{Pt} and \texttt{Alg}'s reduction relations, I wrote one or more tests to check for correct behaviour. Each test consists of an initial program, and the expected state of the program after applying the reduction relation with the Racket function \texttt{apply-reduction-relation} once. For each test I also checked using the \texttt{traces} function that the rule being tested was indeed the rule by which the program was reduced. The 

\section{Functional tests}\label{testfun}

\section{Summary}

\chapter{Conclusion}

The original aim for the project was to create a CEK machine that modelled the semantics of algebraic effects; and then to use this machine to be able to determine whether particular schedulers or programs had certain properties. I successfully achieved both of these goals.

I have deviated from the project proposal because of a better understanding of the project. The success criteria in the proposal focused on determining whether my CEK machine implementation was correct in that it corresponded to the algebraic effects semantics. This included 'random testing', which I did not perform. However, I expanded on the criteria by going on to use the implementation to find whether certain schedulers were deterministic and complete, and this task has been successfully evaluated. If I were to carry out the project again, I would focus less on the correctness of my implementation and more on its use as a tool to test schedulers and programs.

Overall, the project has been a success: my parasitic threads implementation of the existing description as a CEK machine has brought this description from the abstract to the concrete, and has found mistakes in that description; my implementation of algebraic effects worked and had enough functionality to write basic schedulers; and these schedulers were tested for completion and termination.

\addcontentsline{toc}{chapter}{Bibliography}
\bibliographystyle{unsrt}

\bibliography{ref}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% the appendices
\appendix

\chapter{Project Proposal}

\chapter{Unit tests}
\section{\texttt{Pt}}
\begin{tabular}{| p{3cm} | p{5cm} |  p{5cm} | p{1.5cm} |}
\hline
\textbf{Rule} & \textbf{Input} & \textbf{Expected output} & \textbf{Result} \\ \hline
value & (control unit ($\rho$) ()) & (return ((ret unit))) & Passed \\ \hline
variable & (control x (ρ (x unit)) ()) & (return ((ret unit))) & Passed \\ \hline
closure & (control (λ x x) (ρ) ()) & (return ((ret (λ x x (ρ))))) & Passed \\ \hline
application & (control ((λ x x) unit) (ρ) ()) & (control (λ x x) (ρ) ((arg unit (ρ)))) & Passed \\ \hline
argument & (return ((ret (λ x x (ρ))) (arg unit (ρ)))) & (control unit (ρ) ((fun (λ x x (ρ))))) & Passed \\ \hline
function & (return ((ret unit) (fun (λ x x (ρ))))) & (control x (ρ (x unit)) ()) & Passed \\ \hline
spawnParasite & (control (spawn unit) (ρ) ()) & (control unit (ρ) () ((ret unit))) & Passed \\ \hline
attachParasite & (control (attach ((ret unit))) (ρ) ()) & (return ((ret unit)) ((ret unit))) & Passed \\ \hline
threadHalt & (return ((ret unit))) & (halt unit) & Passed \\ \hline
parasiteHalt &   &  & Passed \\ \hline
\end{tabular}

\section{\texttt{Alg}}

\end{document}
