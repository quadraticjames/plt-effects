% Template for a Computer Science Tripos Part II project dissertation
\documentclass[12pt,a4paper,twoside,openright]{report}
\usepackage[pdfborder={0 0 0}]{hyperref}    % turns references into hyperlinks
\usepackage[margin=25mm]{geometry}  % adjusts page layout
\usepackage{graphicx}  % allows inclusion of PDF, PNG and JPG images
\usepackage{verbatim}
\usepackage{listings}
\usepackage{color}
\usepackage{courier}

\definecolor{myblue}{rgb}{0,0.05,0.75}

\lstset{,
aboveskip=20pt,
backgroundcolor = \color{white},
basicstyle = \footnotesize\ttfamily,
belowskip=10pt,
breakatwhitespace=false,
breaklines=false,
captionpos=b,
commentstyle = \color{myblue},
extendedchars=true,
frame=single,
keepspaces=true,
language=Tex,
mathescape,
numbers=left,
numbersep=5pt,
numberstyle=\tiny\color{myblue},
stepnumber=1,
xleftmargin=.2\textwidth,
xrightmargin=.2\textwidth
}

\raggedbottom                           % try to avoid widows and orphans
\sloppy
\clubpenalty1000%
\widowpenalty1000%

\renewcommand{\baselinestretch}{1.1}    % adjust line spacing to make
                                        % more readable

\begin{document}

\bibliographystyle{plain}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Title


\pagestyle{empty}

\rightline{\LARGE \textbf{James Wright}}

\vspace*{60mm}
\begin{center}
\Huge
\textbf{Formalising the semantics of algebraic effects in OCaml} \\[5mm]
Computer Science Tripos -- Part II \\[5mm]
Trinity Hall \\[5mm]
\today  % today's date
\end{center}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Proforma, table of contents and list of figures

\pagestyle{plain}

\chapter*{Proforma}

{\large
\begin{tabular}{p{4.4cm}p{11cm}}
Name:               & \bf James Wright                       \\
College:            & \bf Trinity Hall                     \\
Project Title:      & \bf Formalising the semantics of algebraic effects in OCaml \\
Examination:        & \bf Computer Science Tripos -- Part II, 2015--16  \\
Word Count:         & \bf unknown  \\
Project Originator: & KC Sivaramakrishnan                    \\
Supervisor:         & KC Sivaramakrishnan                    \\ 
\end{tabular}
}


\section*{Original Aims of the Project}

To formalise the semantics of algebraic effects, a proposed addition to OCaml, as a CEK machine, in order to perform subsequent random and exhaustive testing of concurrent schedules in the program. The testing should allow us to show desirable properties such as determinism and absence of deadlock.

\section*{Work Completed}

\section*{Special Difficulties}

None.
 
\newpage
\section*{Declaration}

I, James Wright of Trinity Hall, being a candidate for Part II of the Computer
Science Tripos, hereby declare
that this dissertation and the work described in it are my own work,
unaided except as may be specified below, and that the dissertation
does not contain material that has already been used to any substantial
extent for a comparable purpose.

\bigskip
\leftline{Signed}

\medskip
\leftline{Date}

\tableofcontents

\listoffigures

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% now for the chapters

\pagestyle{headings}

\chapter{Introduction}

\section{Algebraic effects}

There exist multicore-capable functional programming languages, such as Haskell, Manticore, F\#, and MultiMLton, whose runtimes provide support for concurrency---the concurrency primitives are baked in to the runtime system. This has the advantage of natively supporting multicore capabilities, but it also means that the runtimes can become burdensomely complicated. OCaml, on the other hand, is not yet multicore-capable and does not have this concurrency support.
Algebraic effects is a proposed addition to OCaml that would provide this. In contrast to the implementations in the other aforementioned functional programming languages, algebraic effects provide a modular abstraction for expressing effectful computation, which allows programmers to implement independent schedulers and new concurrency primitives as OCaml libraries.

\section{Formalisation}

The syntax and semantics for algebraic effects have been designed and implemented by OCaml Labs, but the new semantics has not yet been formalised. Formalisation allows for random and exhaustive testing of concurrent schedules, which would allow us to show properties such as determinism or absence of deadlock.

\chapter{Preparation}

\section{PLT Redex}

For the formalisation I chose to use PLT Redex, which is a language embedded in Racket that is designed for specifying and testing operational semantics. The structure of a PLT Redex program can include:

\begin{itemize}
\item the specification of the language whose semantics are being described (the syntax);
\item a reduction relation on the language (the semantics);
\item unit tests for regression testing; and
\item the type system for the language.
\end{itemize}

I familiarised myself with PLT Redex through the Racket tutorial\footnote{http://docs.racket-lang.org/redex/tutorial.html}, on which the following demonstration is based. The tutorial implements a model of the $\lambda$-calculus with an additional 'amb' operator. This introduced the main concepts of the language that I would later use to formalise algebraic effects.

\begin{lstlisting}[caption=Defining a language in PLT Redex,label={lst:redex1}]
(define-language L
  (e (e e)         %application
      ($\lambda$ x e)      %lambda function
      x            %variable
      (amb e ...)) %amb operator
  (x variable-not-otherwise-mentioned))
\end{lstlisting}

A language is described by a set of non-terminals and expressions that match these non-terminals. In Listing \ref{lst:redex1} the non-terminals are \texttt{e} and \texttt{x}.

In order to write a reduction relation, it is idiomatic to write a small extension to the language that not only defines what it means for an expression in the language to be a program, but also defines the evalation context.

\begin{lstlisting}[caption=An extended language based on L,label={lst:redex2}]
(define-extended-language Ext L
  (p (e ...))
  (P (e ... E e ...))
  (E (v E)
     (E e)
     hole)
  (v ($\lambda$ x e)))
\end{lstlisting}

In Listing \ref{lst:redex2} the non-terminal \texttt{p}, which represents a program, is matched to a (possibly zero-length) list of \texttt{e}. The non-terminal \texttt{E} represents an evaluation context, and is matched to the special symbol \texttt{hole} in order to identify it as such. In order that a function is evaluated before its argument, \texttt{E} is matched to the expression \texttt{(v E)}, rather than to \texttt{(e E)}.

\begin{lstlisting}[caption=Defining a reduction relation in PLT Redex,label={lst:redex3}]
(define red
  (reduction-relation
   Ext
  #:domain p
   (--> (in-hole P (($\lambda$ (x t) e) v))
        (in-hole P (subst x v e))
        "application")
   (--> (e_1 ... (in-hole E (amb t e_2 ...)) 
          e_3 ...)
        (e_1 ... (in-hole E e_2) ... e_3 ...)
        "amb")))
\end{lstlisting}

The reduction relation is defined in Listing \ref{lst:redex3}. The first rule, \texttt{"application"}, uses a separately-defined metafunction \texttt{subst} to reduce a function application to the expression within the function, with the bound variable being substituted by the value of the argument. The second rule, \texttt{"amb"}, defines the semantics of amb.

\chapter{Implementation}

\section{Parasitic threads}
Parasitic threads are a system for implementing multi-thread behaviour inside a single processor thread. The processor thread maintains a list of parasitic threads, and a list of channels. Each parasitic thread is made up of one or more parasites. These are similar to subroutines on a call stack. The parasite on top is the one that is being executed. Execution may include: 

\begin{itemize}
\item spawning a parasite, which creates a new parasite that is put on top of the stack; 
\item sending a value into a channel;
\item receiving a value from a channel; and 
\item terminating, which removes the parasite from the stack without returning a value to the parasite beneath it.
\end{itemize}

The scheduling of threads is handled implicitly by the system, which is free to pre-empt a thread at any time.  Threads may synchronise exclusively through sending values into channels, which are the only way through which two threads can communicate. Channels are non-buffering, that is, execution of a sender is blocked until another parasite tries to receive from the same channel.

A parasite can be in one of three states: 'control', 'return', and 'halt'. A parasite in the control state is in the process of evaluating an expression. When the expression has been reduced to a value, a \texttt{ret v} frame is pushed on to the stack, and the parasite is moved to the return state. The halt state signifies that execution of the entire thread has finished.

The full semantics of parasitic threads are presented by Sivaramakrishnan, et al., in MultiMLton: A multicore-aware runtime for standard ML.\footnote{SIVARAMAKRISHNAN, K., ZIAREK, L. and JAGANNATHAN, S. (2014). MultiMLton: A multicore-aware runtime for standard ML. J. Funct. Prog., 24(06), pp.613-674.}

\section{Algebraic effects}

The system of algebraic effects is based on parasitic threads. The key distinction is that scheduling is now handled explicitly by the program that is being executed. The execution occurs entirely within a single thread, which is made up of a fibre stack -- analogous to the parasite stack of parasitic threads. Each fibre is also made up of a stack of frames. Another difference is that when a fibre terminates, \textit{i.e.}, the fibre is in the return state and the only frame on the frame stack is a \texttt{ret v} frame, the value \texttt{v} \textbf{is} returned to the fibre beneath it on the fibre stack.

The explicit scheduling involves the addition of two new forms of expression to the language. The semantics of the first, \texttt{handle(fibre, h\_eff, h\_val)}, are equivalent to that given in Listing \ref{lst:handle}.

\begin{lstlisting}[caption=The semantics of \texttt{handle},label={lst:handle}]
  match g() with:
    | v            => h_val(v)
    | effect(k, v) => h_eff(k, v)
\end{lstlisting}

\section{whatever}

Since the semantics of algebraic effects are similar to and based on the semantics of parasitic threads, and the semantics of parasitic threads were already given in that paper, I decided to implement these semantics first, and then modify the result to fit the semantics of algebraic effects.



\chapter{Evaluation}

\chapter{Conclusion}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% the appendices
\appendix

\chapter{Project Proposal}

\end{document}
