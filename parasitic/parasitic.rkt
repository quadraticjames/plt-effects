#lang racket
(require redex)

(define-language Pt
  (e x
     v
     (e e))
  (v unit
     (λ x e r)
     k)
  (x variable-not-otherwise-mentioned)
  (r (ρ (x v) ...))
  (k (f ...))
  (f (ret v)
     (arg e x))
  (s (control e r k_0 k_1 ...)
     (return k ...)
     (halt v)))

(define-extended-language Ev Pt
  (p s)
  (P S)
  (S s
     hole))

(define red
  (reduction-relation
   Ev
   #:domain p
   (--> ((in-hole H (control chan r (f ...) k_1 ...)) (χ (c_1 (k_2 ...) (k_3 ...)) ...))
        ((in-hole H (return ((ret (fresh c)) f ...) k_1 ...)) (χ c (c_1 (k_2 ...) (k_3 ...)) ...))
        "channel")
   (--> ((τ (t_left s_left) ...
            (t (control (spawnhost e) r (f ...) k ...))
            (t_right s_right) ...)
         C)
        ((τ (t_left s_left) ...
            (t (return ((ret unit) f ...) k ...))
            (t_right s_right) ...
            ((fresh t_1) (control e r ())))
         C)
        "spawnhost")
   (--> ((τ (t_left s_left) ...
            (t (control (inflate e) r (f ...) k ...))
            (t_right s_right) ...)
         C)
        ((τ (t_left s_left) ...
            (t (return k ...))
            (t_right s_right) ...
            ((fresh t_1) (control e r (f ...))))
         C)
        "inflate")
   (--> ((in-hole H (return ((sblk c v) f ...) k ...))
         (in-hole N (c (k_1 ...) ())))
        ((in-hole H (return k ...))
         (in-hole N (c (k_1 ... ((sblk c v) f ...)) ())))
        "sendreify")
   (--> ((in-hole H (return ((rblk c) f ...) k ...))
         (in-hole N (c () (k_1 ...))))
        ((in-hole H (return k ...))
         (in-hole N (c () (k_1 ... ((rblk c) f ...)))))
        "recvreify")
   (--> ((in-hole H (return ((sblk c v) f_1 ...) k_1 ...))
         (in-hole N (c (k_s ...) (((rblk c) f_2 ...) k_r ...))))
        ((in-hole H (return (((ret v) f_2 ...) ((ret unit) f_1 ...) k_1 ...)))
         (in-hole N (c (k_s ...) (k_r ...))))
        "sendMatch")
   (--> ((in-hole H (return ((rblk c) f_1 ...) k_1 ...))
         (in-hole N (c (((sblk c v) f_2 ...) k_s ...) (k_r ...))))
        ((in-hole H (return ((ret unit) f_2 ...) ((ret v) f_1 ...) k_1 ...))
         (in-hole N (c (k_s ...) (k_r ...))))
        "recvMatch")
   (--> ((in-hole H (control κ r (f ...) k ...)) C)
        ((in-hole H (return ((ret κ) f ...) k ...)) C)
        "constant")
   (--> ((in-hole H (control x r (f ...) k ...)) C)
        ((in-hole H (return ((ret x) f ...) k ...)) C)
        "variable")
   (--> ((in-hole H (control (λ x e r) r (f ...) k ...)) C)
        ((in-hole H (return ((ret (λ x e r)) f ...) k ...)) C)
        "closure")
   (--> ((in-hole H (control (e_1 e_2) r (f ...) k ...)) C)
        ((in-hole H (control e_1 r ((arg e_2 r) f ...) k ...)) C)
        "application")
   (--> ((in-hole H (control (reify e) r k_0 k_1 ...)) C)
        ((in-hole H (control (e k_0) r () k_1 ...)) C)
        "reify")
   (--> ((in-hole H (control (send e_1 e_2) r (f ...) k ...)) C)
        ((in-hole H (control e_1 r ((sval e_2 r) f ...) k ...)) C)
        "send")
   (--> ((in-hole H (control (prepare e_1 e_2) r (f ...) k ...)) C)
        ((in-hole H (control e_1 r ((pval e_2 r) f ...) k ...)) C)
        "prepare")
   (--> ((in-hole H (control (recv e) r (f ...) k ...)) C)
        ((in-hole H (control e r (recv f ...) k ...)) C)
        "receive")
   (--> ((in-hole H (control (spawnParasite e) r (f ...) k ...)) C)
        ((in-hole H (control e r () ((ret unit) f ...) k ...)) C)
        "spawnParasite")
   (--> ((in-hole H (control (attach k_0) r (f ...) k_1 ...)) C)
        ((in-hole H (return k_0 ((ret unit) f ...) k_1 ...)) C)
        "attachParasite")
   (--> ((in-hole H (return ((ret v)))) C)
        ((in-hole H (halt v)) C)
        "threadHalt")
   (--> ((in-hole H (return ((ret v)) k ...)) C)
        ((in-hole H (return k ...)) C)
        "parasiteHalt")
   (--> ((in-hole H (return ((ret v) (arg e r) f ...) k ...)) C)
        ((in-hole H (control e r ((fun v) f ...) k ...)) C)
        "argument")
   (--> ((in-hole H (return ((ret v) (fun (λ x e (ρ (x_0 v_0) ...))) f ...) k ...)) C)
        ((in-hole H (control e (ρ (x_0 v_0) ... (x v)) (f ...) k ...)) C)
        "function")
   (--> ((in-hole H (return ((ret k_0) (pval e r) f ...) k ...)) C)
        ((in-hole H (control e r ((prep k_0) f ...) k ...)) C)
        "prepareValue")
   (--> ((in-hole H (return ((ret v) (prep f_0 ...) f ...) k ...)) C)
        ((in-hole H (return ((ret ((ret v) f_0 ...)) f ...) k ...)) C)
        "prepareFinalize")
   (--> ((in-hole H (return ((ret c) (sval e r) f ...) k ...)) C)
        ((in-hole H (control e r ((send c) f ...) k ...)) C)
        "sendValue")
   (--> ((in-hole H (return ((ret v) (send c) f ...) k ...)) C)
        ((in-hole H (return ((sblk c v) f ...) k ...)) C)
        "sendBlock")
   (--> ((in-hole H (return ((ret c) recv f ...) k ...)) C)
        ((in-hole H (return ((rblk c) f ...) k ...)) C)
        "recvBlock")
   ))

(define-metafunction Ev
  var-lookup : r x -> v
  [(var-lookup (ρ (x v) (x_1 v_1) ...) x)
   v]
  [(var-lookup (ρ (x_0 v_0) (x_1 v_1) ...) x)
   (var-lookup (ρ (x_1 v_1) ...) x)])
